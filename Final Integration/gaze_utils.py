#!/usr/bin/env python3
"""
Sample Main Application - Gaze Direction Interpreter
======================================================
This demonstrates how the main application would use the calibration data
generated by gaze_calibrator.py to interpret gaze directions.
"""

import json
import os
#Deleted tuple IMPORT
from typing import Dict, Optional
import numpy as np



class GazeDirectionInterpreter:
    """
    Interprets raw gaze data into discrete directions using calibration data.
    This class is used by the main application to convert continuous gaze
    values into discrete directional commands.
    """
    
    def __init__(self, calibration_file: str = "gaze_direction_calibration.json"):
        """
        Initialize the interpreter with calibration data.
        
        Args:
            calibration_file: Path to the calibration JSON file
        """
        self.calibration_file = calibration_file
        self.calibration_data = None
        self.is_loaded = False
        
        # Load calibration data
        self.load_calibration()
    
    def load_calibration(self) -> bool:
        """
        Load calibration data from JSON file.
        
        Returns:
            True if successfully loaded, False otherwise
        """
        if not os.path.exists(self.calibration_file):
            print(f"Calibration file not found: {self.calibration_file}")
            print("Please run gaze_calibrator.py first to generate calibration data")
            return False
        
        try:
            with open(self.calibration_file, 'r') as f:
                self.calibration_data = json.load(f)
            
            # Remove metadata if present
            if "_metadata" in self.calibration_data:
                metadata = self.calibration_data.pop("_metadata")
                print(f"Loaded calibration from: {metadata.get('calibration_date', 'unknown')}")
                print(f"Screen resolution: {metadata.get('screen_resolution', 'unknown')}")
            
            self.is_loaded = True
            print(f"Successfully loaded calibration with {len(self.calibration_data)} directions")
            return True
            
        except Exception as e:
            print(f"Error loading calibration file: {e}")
            return False
    
    def interpret_gaze(self, pitch: float, yaw: float) -> Optional[str]:
        """
        Interpret raw gaze values into a discrete direction.
        
        Args:
            pitch: Pitch value in radians (vertical component)
            yaw: Yaw value in radians (horizontal component)
        
        Returns:
            Direction name (e.g., "center", "up", "left") or None if no match
        """
        if not self.is_loaded:
            return None
        
        # Check each direction's thresholds
        for direction_name, thresholds in self.calibration_data.items():
            x_thresh = thresholds.get("x_threshold", [])
            y_thresh = thresholds.get("y_threshold", [])
            
            if len(x_thresh) != 2 or len(y_thresh) != 2:
                continue
            
            # Check if gaze falls within this direction's thresholds
            # Note: yaw corresponds to x (horizontal), pitch to y (vertical)
            if (x_thresh[0] <= yaw <= x_thresh[1] and
                y_thresh[0] <= pitch <= y_thresh[1]):
                return direction_name
        
        return None  # No matching direction found
    
    def get_direction_confidence(self, pitch: float, yaw: float, 
                                direction: str) -> float:
        """
        Calculate confidence score for a specific direction.
        
        Args:
            pitch: Pitch value in radians
            yaw: Yaw value in radians
            direction: Direction to check
        
        Returns:
            Confidence score (0.0 to 1.0)
        """
        if not self.is_loaded or direction not in self.calibration_data:
            return 0.0
        
        thresholds = self.calibration_data[direction]
        x_thresh = thresholds.get("x_threshold", [])
        y_thresh = thresholds.get("y_threshold", [])
        
        if len(x_thresh) != 2 or len(y_thresh) != 2:
            return 0.0
        
        # Calculate distance from center of threshold region
        x_center = (x_thresh[0] + x_thresh[1]) / 2
        y_center = (y_thresh[0] + y_thresh[1]) / 2
        x_range = (x_thresh[1] - x_thresh[0]) / 2
        y_range = (y_thresh[1] - y_thresh[0]) / 2
        
        # Normalize distance
        if x_range > 0 and y_range > 0:
            x_dist = abs(yaw - x_center) / x_range
            y_dist = abs(pitch - y_center) / y_range
            
            # Confidence decreases with distance from center
            # Using Euclidean distance in normalized space
            normalized_dist = np.sqrt(x_dist**2 + y_dist**2)
            confidence = max(0.0, 1.0 - normalized_dist)
            
            return confidence
        
        return 0.0
    
    def get_all_directions_confidence(self, pitch: float, yaw: float) -> Dict[str, float]:
        """
        Get confidence scores for all directions.
        
        Args:
            pitch: Pitch value in radians
            yaw: Yaw value in radians
        
        Returns:
            Dictionary mapping direction names to confidence scores
        """
        if not self.is_loaded:
            return {}
        
        confidences = {}
        for direction in self.calibration_data.keys():
            confidences[direction] = self.get_direction_confidence(pitch, yaw, direction)
        
        return confidences
    
    def print_calibration_summary(self):
        """Print a summary of the loaded calibration data."""
        if not self.is_loaded:
            print("No calibration data loaded")
            return
        
        print("\n" + "="*60)
        print("CALIBRATION DATA SUMMARY")
        print("="*60)
        
        for direction in sorted(self.calibration_data.keys()):
            thresholds = self.calibration_data[direction]
            x_thresh = thresholds.get("x_threshold", [])
            y_thresh = thresholds.get("y_threshold", [])
            
            if len(x_thresh) == 2 and len(y_thresh) == 2:
                print(f"{direction:12} -> "
                      f"Yaw: [{np.degrees(x_thresh[0]):6.2f}째, {np.degrees(x_thresh[1]):6.2f}째] "
                      f"Pitch: [{np.degrees(y_thresh[0]):6.2f}째, {np.degrees(y_thresh[1]):6.2f}째]")
        print("="*60 + "\n")
